<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrum Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        #scheduleData table {
            width: 100%;
            border-collapse: collapse;
            background-color: #4b4b4b; /* Set the background color for the table */
        }
        #scheduleData th, #scheduleData td {
            text-align: left;
            padding: 8px; 
            font-size: 10px; /* Adjust font size as needed */
            /* border-bottom: 1px solid #333; Optional: add a subtle border for separation */
            color: #fff; /* Set text color for better contrast against the dark background */
        }
        #scheduleData tr {
            background-color: #4b4b4b; /* Ensures entire row is consistent color */
        }
        #scheduleData th {
            /* position: sticky; */
            top: 0; /* Make the header stick to the top */
            background-color: #333; /* Slightly darker background for the header */
            z-index: 2; /* Ensure the header is above other content */
        }
    </style>
    
    
    
</head>
<body class="bg-black text-white">
    <div class="grid grid-cols-2 grid-rows-2 h-screen">
        <div class="frequency-data border border-white p-4">
            <canvas id="lineChart"></canvas>
        </div>
        <div id="right" class="quadrant border border-white row-span-2 p-4 flex flex-col justify-center items-center">
            <div id="scheduleData">Loading schedule data...</div>
        </div>
        <div id="spectrogramPlot" class="quadrant border border-white p-4"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
        let lineChart;
        let spectrogramData = [{
            z: [],
            type: 'heatmap',
            colorscale: 'Viridis',
            zmin: -140,
            zmax: -40,
        }];
        let timestamps = [];
        let timeIndex = 0;
        let lastPlottedData = null;

        const headers = ["ITEM", "SAT", "DIR", "EL", "MODE", "START", "END"];
        const table = document.createElement('table');
        table.classList.add('table-auto', 'w-full', 'text-left', 'whitespace-normal');

        async function fetchDailySchedule() {
            try {
                const response = await fetch('/daily-schedule');
                const schedule = await response.json();

                const scheduleElement = document.getElementById('scheduleData');
                scheduleElement.innerHTML = ''; // Clear existing content

                // Create a table
                const table = document.createElement('table');
                table.classList.add('table'); // Add 'table' class for styling if you're using a CSS framework like Bootstrap

                // Create the header row
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headers.forEach(headerText => {
                    const header = document.createElement('th');
                    header.textContent = headerText;
                    headerRow.appendChild(header);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Create the body of the table
                const tbody = document.createElement('tbody');
                schedule.forEach(item => {
                    const row = document.createElement('tr');
                    headers.forEach(header => {
                        const cell = document.createElement('td');
                        // Map the header to the item's property and handle undefined properties
                        let text = '';
                        switch (header) {
                            case 'ITEM': text = item.item || 'N/A'; break;
                            case 'SAT': text = item.sat || 'N/A'; break;
                            case 'DIR': text = item.dir || 'N/A'; break;
                            case 'EL': text = item.el || 'N/A'; break;
                            case 'MODE': text = item.mode || 'N/A'; break;
                            case 'START': text = item.start || 'N/A'; break;
                            case 'END': text = item.end || 'N/A'; break;
                        }
                        cell.textContent = text;
                        row.appendChild(cell);
                    });
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);

                // Append the table to the scheduleElement
                scheduleElement.appendChild(table);
            } catch (error) {
                console.error('Error fetching daily schedule:', error);
                document.getElementById('scheduleData').textContent = 'Failed to load schedule.';
            }
        }

        function shouldUpdateCharts(newData) {
            let newDataString = JSON.stringify(newData);
            if (newDataString === lastPlottedData) {
                // Data hasn't changed, no need to update
                return false;
            }
            // Data has changed, update needed
            lastPlottedData = newDataString;
            return true;
        }

        // Function to initialize/update the Chart.js line chart
        function updateLineChart(labels, values, timestamp) {
            if (lineChart) {
                lineChart.data.labels = labels;
                lineChart.data.datasets[0].data = values;
                lineChart.options.plugins.title.text = 'Data as of ' + timestamp + ' UTC';
                lineChart.update();
            } else {
                const ctx = document.getElementById('lineChart').getContext('2d');
                lineChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: values,
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.1
                        }]
                    },
                    options: {
                        plugins: {
                            title: {
                                display: true,
                                text: 'Data as of ' + timestamp
                            },
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: true,
                                callbacks: {
                                    label: function(context) {
                                        return context.parsed.y + ' dBm';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                min: -140,
                                max: -60,
                                ticks: {
                                    stepSize: 5
                                }
                            }
                        }
                    }
                });
            }
        }

        // Function to initialize/update the spectrogram
        function updateSpectrogram(frequencies, values) {
            spectrogramData[0].z.push(values);

            let now = new Date();
            timestamps.push(now);

            // Format timestamps for display
            let formattedTimestamps = timestamps.map(t => {
                let hours = t.getUTCHours().toString().padStart(2, '0');
                let minutes = t.getUTCMinutes().toString().padStart(2, '0');
                let seconds = t.getUTCSeconds().toString().padStart(2, '0');
                return `${hours}:${minutes}:${seconds}`;
            });

            // Dynamic label calculation for x-axis
            let plotWidth = document.getElementById('spectrogramPlot').clientWidth;
            let maxLabelsX = plotWidth / 50;
            let tickSpacingX = Math.max(1, Math.floor(frequencies.length / maxLabelsX));

            let tickvals = [];
            let ticktext = [];
            for (let i = 0; i < frequencies.length; i += tickSpacingX) {
                tickvals.push(i); 
                ticktext.push(`${frequencies[i].toFixed(2)} MHz`);
            }

            // Dynamic label calculation for y-axis
            let plotHeight = document.getElementById('spectrogramPlot').clientHeight;
            let maxLabelsY = plotHeight / 50;
            let tickSpacingY = Math.max(1, Math.floor(timestamps.length / maxLabelsY));

            let tickValsY = [];
            let tickTextsY = [];
            for (let i = 0; i < timestamps.length; i += tickSpacingY) {
                tickValsY.push(i);
                tickTextsY.push(formattedTimestamps[i]);
            }

            // Keep the number of time slices and timestamps in sync + remove the oldest timestamp
            const maxTimeSlices = 50;
            if (spectrogramData[0].z.length > maxTimeSlices) {
                spectrogramData[0].z.shift();
                timestamps.shift();
            }

            // Update and plot the magic
            Plotly.react('spectrogramPlot', spectrogramData, {
                xaxis: {
                    tickvals: tickvals,
                    ticktext: ticktext,
                    tickangle: -45,
                },
                yaxis: {
                    tickvals: tickValsY,
                    ticktext: tickTextsY,
                },
                colorscale: 'Viridis',
                zmin: -140,
                zmax: -40,
                type: 'heatmap',
                colorbar: {
                    title: 'Power (dBm)',
                    titleside: 'right',
                },
                autosize: false,
                width: 1200,
                height: 600,
                plot_bgcolor: 'black',
                paper_bgcolor: 'black',
                margin: {
                    l: 80,
                    r: 50,
                    b: 100,
                    t: 50,
                    pad: 4
                }
            }, {
                displayModeBar: false
            });
        }

        async function fetchData() {
            const response = await fetch('/data');
            const newData = await response.json();

            if (shouldUpdateCharts(newData)) {
                const frequencies = Object.keys(newData).map(parseFloat);
                const values = Object.values(newData);

                let now = new Date();
                let formattedTimestamp = now.toISOString().replace('T', ' ').slice(0, 19);

                updateLineChart(frequencies, values, formattedTimestamp);
                updateSpectrogram(frequencies, values);
            }
        }

        // Fetch and update data every second
        setInterval(fetchData, 500);

        fetchDailySchedule();

    </script>
</body>
</html>
